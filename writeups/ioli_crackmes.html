<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="description" content="Siddarth's Website">
		<meta name="author" content="Siddarth Senthilkumar">
		<meta name="msapplication-TileColor" content="#ffffff">
		<meta name="msapplication-TileImage" content="../images/icons/name-logo.png">
		<link href="../css/custom.css" rel="stylesheet">
        <link rel="icon" href="../images/icons/name-logo.png">

        <!--Let browser know website is optimized for mobile-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

        <!--Import Google Icon Font-->
        <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <!--Import materialize.css-->
        <link type="text/css" rel="stylesheet" href="../css/materialize.min.css"  media="screen,projection"/>

	    <title>Sid | IOLI Crackmes</title>
	</head>

	<body>
        <main>
            <!-- Navigation bar -->
            <nav>
                <div class="nav-wrapper grey darken-4">
                    <a href="#" data-activates="mobile-demo" class="button-collapse"><i class="material-icons">menu</i></a>
                    <ul class="left hide-on-med-and-down nav-bar">
                        <li><a href="../index.html">Home</a></li>
                        <li><a href="../projects.html">Projects</a></li>
                        <li><a href="../writeups.html" class="active">Writeups</a></li>
                        <li><a href="../courses.html">Coursework</a></li>
                        <li><a href="../resources/Sids-Resume.pdf" target="_blank">Résumé / CV</a></li>
                    </ul>
                    <ul class="right hide-on-med-and-down nav-bar">
                        <li><a href="../greyhat.html">GreyHat</a></li>
                    </ul>
                    <ul class="side-nav nav-bar" id="mobile-demo">
                        <li><a href="../index.html">Home</a></li>
                        <li><a href="../projects.html">Projects</a></li>
                        <li><a href="../writeups.html" class="active">Writeups</a></li>
                        <li><a href="../courses.html">Coursework</a></li>
                        <li><a href="../greyhat.html">GreyHat</a></li>
                        <li><a href="../resources/Sids-Resume.pdf">Résumé / CV</a></li>
                    </ul>
                </div>
            </nav>

            <!-- Page Body -->
            <div class="container">
                <h3>IOLI Crackmes</h3>
                <hr>
                <div class="row">
                    <div class="col s12 m12 l12">
                        The problems below can be found <a href="http://security.cs.rpi.edu/courses/binexp-spring2015/lectures/2/challenges.zip">here</a>. A crackme is a challenge where you are given a compiled program that requires certain input to give access to a user. In order to discover what the input is, you will need to reverse engineer the application and trace what happens to the input.

                        <h5>Table of Contents</h5>
                        <hr>
                        <ol type="I">
                            <li><a href="#setup">Setup</a></li>
                            <li><a href="#crackme0x00a">crackme0x00a</a></li>
                            <li><a href="#crackme0x00b">crackme0x00b</a></li>
                            <li><a href="#crackme0x01">crackme0x01</a></li>
                            <li><a href="#crackme0x02">crackme0x02</a></li>
                            <li><a href="#crackme0x03">crackme0x03</a></li>
                            <li><a href="#crackme0x04">crackme0x04</a></li>
                            <li><a href="#crackme0x05">crackme0x05</a></li>
                            <li><a href="#crackme0x06">crackme0x06</a></li>
                            <li><a href="#crackme0x07">crackme0x07</a></li>
                            <li><a href="#crackme0x08">crackme0x08</a></li>
                            <li><a href="#summary">Summary</a></li>
                        </ol>

                        <a name="setup"></a>
                        <h5>Setup</h5>
                        <hr>
                        <b>Peda Installation</b><br />
                        My first step in this process was to install <a href="https://github.com/longld/peda" target="_blank">peda</a>.
                        Peda is a Python framework for the code debugging tool GDB. GDB is an invaluable tool for reverse engineering,
                        but it requires a lot of manual work to do useful things like displaying the contents of registers and the stack.
                        Peda is an extension that gets added to the .gdbinit script that simplifies these functions for you, saving both time and effort.
<pre><code class="bash">git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
</code></pre>

                        <b>r2 Installation</b><br />
                        Another tool you will need is a disassembler. A disassembler will attempt to take the machine code from the binary and display it in a more human-readable format - assembly. Some disassemblers even come packaged with a decompiler, which goes a step further and can reproduce source code! A few options available are IDA Pro, Binary Ninja, and radare2. I will be using radare2 since it is cross platform, powerful, and most importantly, free.
<pre><code class="bash">git clone https://github.com/radare/radare2.git ~/radare2
cd ~/radare2
sys/install.sh
</code></pre>

                        <b>Common Errors</b><br />
                        Once you have the problems downloaded, first make sure that you can run the binaries.
                        <pre><code class="bash">./crackme0x01</code></pre>
                        If you get an error that says "No such file or directory", then you are likely running a 64-bit OS but are trying to execute a 32-bit binary. To circumvent this error, you can try the following. See <a href="https://askubuntu.com/questions/454253/how-to-run-32-bit-app-in-ubuntu-64-bit" target="_blank">here</a> for more details.
<pre><code class="bash">sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt-get -y install libc6:i386 libncurses5:i386 libstdc++6:i386
</code></pre>
                        If the file still does not execute or shows an error like "cannot execute binary file: Exec format error", then you may just have to get a 32-bit OS to run the binaries natively.
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x00a"></a>
                        <h5>crackme0x00a</h5>
                        <hr>
                        We start by looking at the first crackme. When we run the file, we are given a password prompt. When we input an incorrect password, the program returns by saying "Wrong!" and asks again, presumably until the user enters the right password.
<pre><code class="bash">$ ./crackme0x00a
Enter password: banana
Wrong!
Enter password: apple
Wrong!
Enter password:
</code></pre>           
                        Let's open the binary in r2. The <code>-AAA</code> option indicates that we want the binary to be analyzed completely for things like symbols. This isn't a default option in r2 since analyzing larger binaries can take very long, but for us it should be fine.
<pre><code class="bash">$ r2 crackme0x00a -AAA
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[x] Emulate code to find computed references (aae)
[x] Analyze consecutive function (aat)
[x] Type matching analysis for all functions (afta))unc.* functions (aan)
[x] Type matching analysis for all functions (afta)
 -- Bindiff two files with '$ radiff2 /bin/true /bin/false'
[0x08048430]>
</code></pre>

                        Next, let's search for the main function. We will use the <code>is</code> command in r2 to list all the symbols that it found in its analysis, and then grep for the word "main". In r2, you can grep in the terminal by typing <code>~</code>.
<pre><code class="bash">[0x08048430]> is~main
vaddr=0x080484e4 paddr=0x000004e4 ord=066 fwd=NONE sz=133 bind=GLOBAL type=FUNC name=main
vaddr=0x08048410 paddr=0x00000410 ord=006 fwd=NONE sz=16 bind=GLOBAL type=FUNC name=imp.__libc_start_main
[0x08048430]>
</code></pre>

                        Awesome! We can see that the main function starts at address 0x080484e4. You may have noticed that the shell prompt has an address in it - that is our current location in the file. To seek to somewhere else to begin analyzing that location, we will use the <code>seek</code> command.
<pre><code class="bash">[0x08048430]> s 0x080484e4
[0x080484e4]>
</code></pre>

                        Notice that the current location has changed in the shell prompt. Now, we can begin analyzing the function. r2 is a very powerful tool that contains many different views of the binary. In this challenge, I will show you how to use graph mode. Enter <code>VV</code> and you will see a graphical view displaying different basic blocks separated by calls or jump instructions. You can navigate the graph in the terminal by using Vim movement keys (hjkl). Of interest to us is the following:<br /><br />
                        <img src="../images/writeups/rpisec/crackme_00a_r2.png" class="resize-image" alt="crackme0x00a r2"></img><br /><br />

                        We can clearly see that there is a call to scanf, which reads in a string from stdin. The inputted string is compared against another string, str.g00dJ0B_, by the function strcmp. If the comparison passes, the jump evaluates to false and "Congrats!" is printed. Else, we are met with a text that says "Wrong!". After the incorrect comparison, there is a loop back to the password prompt. What is the value of str.g00dJ0B_? Press q two or three times to quit graphical mode and enter iz~g00dJ0B to find that string:
<pre><code>[0x080484e4]> iz~g00dJ0B
vaddr=0x0804a024 paddr=0x00001024 ordinal=000 sz=9 len=8 section=.data type=ascii string=g00dJ0B!
</code></pre>
                        It's "g00dJ0B!". Let's try this as the password for the crackme. Quit out of r2 and run the crackme again.
<pre><code class="bash">$ ./crackme0x00a
Enter password: g00dJ0B!
Congrats!
</code></pre>
                        Awesome, we solved our first crackme! I know this problem could have been very easily solved if we had just run <code>strings crackme0x00a</code>, but hopefully this writeup gave you an idea for how to use r2.
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x00b"></a>
                        <h5>crackme0x00b</h5>
                        <hr>
                        Running the binary results in identical behavior to the last one. This time, I open it in r2 and print the disassembly of main instead of browsing graphical mode by typing <code>pdf @sym.main</code>.<br /><br />
                        <img src="../images/writeups/rpisec/crackme_00b_r2.png" class="resize-image" alt="crackme0x00b r2"></img><br />
                        We see nearly the same binary except that instead of using the strcmp function to compare two strings, this binary uses wcscmp. A quick lookup at the man page for this function shows that this function is just like strcmp except that it operates on wide character strings instead of normal character strings. The string that the input is being compared against is str.w0wgreat. Searching for that string results in the string "w0wgreat". In this case, r2 was even able to detect and accurately display wide-character strings! In IDA Pro, I had to manually do this, so this was amazing.
<pre><code class="bash">[0x080483e0]> iz~w0wgreat
vaddr=0x0804a040 paddr=0x00001040 ordinal=000 sz=36 len=8 section=.data type=wide32 string=w0wgreat
[0x080483e0]> q

$ ./crackme0x00b
Enter password: w0wgreat
Congrats!
</code></pre>
                        Running the code, we see that the password works. Awesome!
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x01"></a>
                        <h5>crackme0x01</h5>
                        <hr>
                        Now that we know the drill, let's get right into it.<br /><br />
                        <img src="../images/writeups/rpisec/crackme_01_r2.png" class="resize-image" alt="crackme0x01 r2"></img><br /><br />
                        This time, the inputted value is being read by scanf as an integer (the "%d" format string tells us this). What integer is our input being compared against? In the call to cmp, we see the value 149Ah. This is the same as 0x149A, or 5274 in base 10. Entering this as the password grants us access!
<pre><code>$ ./crackme0x01
IOLI Crackme Level 0x01
Password: 5274
Password OK :)
</code></pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x02"></a>
                        <h5>crackme0x02</h5>
                        <hr>
                        Similar to last time, this binary takes an integer as input. However, instead of being compared against another value directly, a series of operations is performed on the other value first. We need to figure out what the final value is that's being compared against our input.<br /><br />
                        <img src="../images/writeups/rpisec/crackme_02_r2.png" class="resize-image" alt="crackme0x02 r2"></img><br />
                         There are two ways to solve this problem - to walk through the instructions by hand to see what the operations are and compute the value manually, or to use a debugger. In our case, we will use a debugger. Using a debugger, we can just "pause" the execution of the program after the value is computed and print it out - without having to do any of the hard work of manual calculations :)<br /><br />
                        Open GDB by typing:
<pre><code class="bash">gdb crackme0x02
</code></pre>
                        Once open, type the following to set a breakpoint on the cmp instruction.
<pre><code class="bash">b *0x0804844E
</code></pre>
                        The above is the syntax to set a breakpoint on a specific instruction's memory address in GDB. Now, type "run" to run the program in GDB and enter any password when prompted. GDB will resume execution until it hits the breakpoint, then peda will display the contents of several useful pieces of information, such as stack contents and register contents. We know that we want to see the value at [local_ch], but local_ch is just a variable name given by r2. In GDB, we see the value of local_ch is actually -0xC. To print the value at this location, type the following. <pre><code>x/1dw $ebp-0xC</code></pre> This will:
                        <ul>
                            <li>- Examine the contents of memory, reading 1 decimal word.</li>
                            <li>- Use the memory address defined by the computation $ebp-0xC</li>
                        </ul>
                        <img src="../images/writeups/rpisec/crackme_02_gdb_address.png" class="resize-image" alt="crackme0x02 gdb"></img><br /><br />
                        The value we get is 338724. Running the program again, we see that we are granted access! Using a debugger can be a lot easier and take a lot less time than going through instructions manually, so use this to your advantage!
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x03"></a>
                        <h5>crackme0x03</h5>
                        <hr>
                        This time, the main function reads in our input and performs calculations, but it doesn't seem to do the actual checking to see if our input was correct - this seems to be done in a function call named test. To view this function, we can type pdf @sym.test in the shell prompt.<br /><br />
                        <img src="../images/writeups/rpisec/crackme_03_r2.png" class="resize-image" alt="crackme0x03 r2"></img><br />
                        It looks like there's some arguments being checked before printing some text, but the text appears jumbled. That text is passed as a parameter to another function called "shift". So, we could guess that the function arguments are our input and the actual password. After the input is checked, one of the two shifted texts is printed, indicating success or failure. So, like before, let's just set a breakpoint on the cmp instruction in GDB and print out the memory location containing our mystery value.<br /><br />
                        <img src="../images/writeups/rpisec/crackme_03_gdb.png" class="resize-image" alt="crackme0x03 gdb"></img><br />
                        It turns out that the value is the same as in the previous challenge, which is 338724. Using this as the password works!
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x04"></a>
                        <h5>crackme0x04</h5>
                        <hr>
                        Opening the binary in r2, we see that the input string is sent as an argument to a function called "check". Inside the test function, we see a few different variables and basic blocks. To get a better idea of what's happening visually, I used graphical mode to see the control flow.<br /><br />
                        <img src="../images/writeups/rpisec/crackme_04_r2.png" class="resize-image" alt="crackme0x04 r2"></img><br />
                         The first block of code that branches checks the length of the input string against some variable. At the bottom, this variable gets incremented and then the code executes at the top again. That variable is likely some kind of index, and we are probably running some kind of for-loop to execute some code as long as our index is less than the length of the string. I renamed the variable, originally "local_ch", to "index" to remember this. This can be done by typing ":" in graphical mode to bring up an integrated shell prompt, then typing <pre><code>afvn local_ch index</code></pre> On the success path basic block, the first few lines read one character from the input string, at the index of our "index" variable. Then, this number is scanned as an integer, and finally added to some kind of running total. When the total hits the value 0xf (15), we get the "Password OK!" message. So, as long as we enter a number whose digits can sum to 15 when summed from left to right, then the program should accept the password. Inputting the number 12345 does the trick, and we are granted access!
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x05"></a>
                        <h5>crackme0x05</h5>
                        <hr>
                        Similar to the last problem, this binary reads in a number and sums the digits one at a time. However, there is a little more that happens - if at any point the sum hits the value 16, a function called "parell" is called.<br /><br />
                        <img src="../images/writeups/rpisec/crackme_05_r2.png" class="resize-image" alt="crackme0x05 r2"></img><br />
                        Inside the parell function, our inputted number is read as a decimal again then bitwise-anded with 1. After this, the test instruction is called. This is just x86's way of checking if the number is even or odd. If the number was odd, then the bitwise-and with 1 would result in the value of 1, and calling the test instruction would not set the zero flag. If it was even, then the bitwise-and would result in 0, and a test instruction would set the zero flag. To get access to the path with the "Password OK!" string, we need the test instruction result to be 0 - in other words, the number must be even. So to gain access, we need to enter an integer whose digits sum to 16 at some point and is even. I chose the number 55510, and it worked!
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x06"></a>
                        <h5>crackme0x06</h5>
                        <hr>
                        Similar to the last problem, this binary reads in a number and sums the digits one at a time. If the digits sum to 16, the function parell is called. Inside parell, we see the same code that checks to see if the input number was even, but before we get to these checks, another function called "dummy" is called. If this function returns zero, then we never get to the even number checks and the program prints "Incorrect password". So, let's check out this new function!<br /><br />
                        <img src="../images/writeups/rpisec/crackme_06_r2.png" class="resize-image" alt="crackme0x06 r2"></img><br />
                        Inside the dummy function, a few interesting things are happening. We see a variable being incremented in the left basic block, and being checked against on the top. This seems like a loop index! So, we will rename this variable.<br /><br />

                        If the top-most basic block cmp ever results in a zero, then we simply return 0, which means we failed. So, we want to take the left path from here. But what is happening in the left path? It looks like there's some string, "LOLO". The left path seems to check if another string's first 3 bytes are the same as "LOLO". In other words, the other string's first 3 letters must be "LOL". But what is this other string? We never passed the input string to this function. Let's fire up GDB and set a breakpoint on the strcmp instruction to find out!<br /><br />
                        <img src="../images/writeups/rpisec/crackme_06_gdb.png" class="resize-image" alt="crackme0x06 gdb"></img><br />
                        Looking at the string, we see something that says "LANG=en_US.UTF-8" (this string may be different for you). This is an environment variable! Could the program be looking through all the environment variables? Let's press "c" in GDB to continue executing the program to find out. The breakpoint hits again, and this time my $eax register points to a string that says "USER=vagrant" (again this may be different for you). So, we are fairly certain that the binary is iterating through the environment variables. A safe assumption at this point would be that the program is looking for an environment variable that begins with "LOL". Let's try running the binary with an environment variable like this.
<pre><code>$ env LOL=1 ./crackme0x06
IOLI Crackme Level 0x06
Password: 55510
Password OK!
</code></pre>
                        Awesome, it worked!           
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x07"></a>
                        <h5>crackme0x07</h5>
                        <hr>
                        As usual, we open and analyze the binary using r2. But this time, when we call <code>pdf @sym.main</code>, we get an error!
<pre><code>[0x08048400]> pdf @sym.main
Invalid address (sym.main)
|ERROR| Invalid command 'pdf @sym.main' (0x70)
</code></pre>
                        This indicates to us that this binary is stripped of its symbols. The symbols are put in by a compiler like gcc when compiling the source. The symbols are what allowed us and developers to easily debug using commands like pdf @sym.main and pdf @sym.check. However, developers should typically strip these symbols when exporting their code for production since they increase the memory footprint and make reverse engineering easier. Fortunately for us, however, we can still perform our analysis even without symbols.


                        We can first observe program behavior by executing it. It appears pretty much identical to the previous problems; it asks us for a password and tells us we are incorrect. Now where do we go?

                        r2's automatically seeks to the entry point of the program. Even without symbols, r2's analysis is very helpful. If you just type "pdf", r2 will attempt to disassemble and print the instructions from the entry point of the program. Notice these lines:
<pre><code>|           0x08048415      51             push ecx
|           0x08048416      56             push esi                    ; void * stack_end
|           0x08048417      687d860408     push main                   ; 0x804867d ; "U\x89\xe5\x81\xec\x88" ; int argc
\           0x0804841c      e867ffffff     call sym.imp.__libc_start_main ; int __libc_start_main(func main, int argc, char **ubp_av, func init, func fini, func rtld_fini, void *stack_end)
</code></pre>
                        r2 actually found the the main function for us! It's located at 0x804867d. So what function are we in right now? The C runtime has to do some initialization before calling the actual main function. This initialization is done in the function called "__libc_start_main". Before this function is called, its arguments have to be pushed onto the stack - and that is where we are right now. Let's seek to the actual main function that we care about.
<pre><code>[0x08048400]> s 0x804867d
[0x0804867d]> pdf
/ (fcn) main 99
|   main (int arg_10h);
|           ; var int local_78h @ ebp-0x78
|           ; arg int arg_10h @ ebp+0x10
|           ; var int local_4h @ esp+0x4
|              ; DATA XREF from 0x08048417 (entry0)
|           0x0804867d      55             push ebp
|           0x0804867e      89e5           mov ebp, esp
|           0x08048680      81ec88000000   sub esp, 0x88
|           0x08048686      83e4f0         and esp, 0xfffffff0
|           0x08048689      b800000000     mov eax, 0
|           0x0804868e      83c00f         add eax, 0xf
|           0x08048691      83c00f         add eax, 0xf
|           0x08048694      c1e804         shr eax, 4
|           0x08048697      c1e004         shl eax, 4
|           0x0804869a      29c4           sub esp, eax
|           0x0804869c      c70424d98704.  mov dword [esp], str.IOLI_Crackme_Level_0x07_n ; [0x80487d9:4]=0x494c4f49 ; "IOLI Crackme Level 0x07\n" ; const char * format
|           0x080486a3      e810fdffff     call sym.imp.printf         ; int printf(const char *format)
|           0x080486a8      c70424f28704.  mov dword [esp], str.Password: ; [0x80487f2:4]=0x73736150 ; "Password: " ; const char * format
|           0x080486af      e804fdffff     call sym.imp.printf         ; int printf(const char *format)
|           0x080486b4      8d4588         lea eax, [local_78h]
|           0x080486b7      89442404       mov dword [local_4h], eax
|           0x080486bb      c70424fd8704.  mov dword [esp], 0x80487fd  ; [0x80487fd:4]=0x7325 ; "%s" ; const char * format
|           0x080486c2      e8d1fcffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x080486c7      8b4510         mov eax, dword [arg_10h]    ; [0x10:4]=0x30002
|           0x080486ca      89442404       mov dword [local_4h], eax
|           0x080486ce      8d4588         lea eax, [local_78h]
|           0x080486d1      890424         mov dword [esp], eax        ; const char * s
|           0x080486d4      e8e0feffff     call sub.strlen_5b9         ; size_t strlen(const char *s)
|           0x080486d9      b800000000     mov eax, 0
|           0x080486de      c9             leave
\           0x080486df      c3             ret
[0x0804867d]>
</code></pre>
                        Wow! Even without symbols, we were able to locate main and get a really nice looking disassembly - thanks r2! From this, we can easily reverse and figure out what is happening - and most of it should look familiar. One thing that may catch you off gurad is the call to "sub.strlen_5b9". This is not actually a call to strlen; it is a call to a function that uses strlen. We can tell this because it's calling sub.strlen instead of sym.imp.strlen like the previous system calls. Once you go into the function, you can rename it by typing <code>d new_function_name</code>.<br /><br />
                        We'll quickly notice that most of this binary is the same as the previous binary. The only difference is that in this binary, there is a counter inside "parell". If the counter gets greater than 9, the binary fails. So, as long as our password is less than 10 digits, and follows the same rules as the previous problem, we should be good to go.
<pre><code>$ env LOL=1 ./crackme0x07
IOLI Crackme Level 0x07
Password: 55510
Password OK!
</code></pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="crackme0x08"></a>
                        <h5>crackme0x08</h5>
                        <hr>
                        I won't go into much detail about this problem because it is literally the exact same algorithm as the previous problem. Why is it a separate challenge then? This binary is even more stripped! We can't use function names at all; instead we're greeted with esoteric functions like <code>fcn.080485b9</code>.
                        But if you can look past this and work your way as before, then you should be all good to go.
                    </div>
                </div>
                <div class="row">
                    <div class="col s12 m12 l12">
                        <a name="summary"></a>
                        <h5>Summary</h5>
                        <hr>
                        Thanks for following along! We've finished the IOLI Crackmes. If you think I've messed up somewhere or you have a better way to solve some of these, please let me know! Hopefully, this has been a good introduction to x86, reverse engineering, and using GDB and r2.
                    </div>
                </div>
            </div>
        </main>

        <!-- Contact Me -->
        <footer class="page-footer grey darken-4">
            <div class="container">
                <div class="center-align row">
                    <div class="col s12 m12 l12">
                        <ul class="contact">
                            <li><a class="waves-effect waves-light btn light-blue" href="https://github.com/sidsenkumar11" target="_blank">GitHub</a></li>
                            <li><a class="waves-effect waves-light btn light-blue" href="https://linkedin.com/in/sidsenkumar11" target="_blank">LinkedIn</a></li>
                            <li><a class="waves-effect waves-light btn light-blue" href="mailto:sidsenkumar11@gmail.com" target="_blank">E-Mail</a></li>
                            <li><a class="waves-effect waves-light btn light-blue" href="resources/Sids-Resume.pdf" target="_blank">Resume</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </footer>

        <!--Import jQuery before materialize.js-->
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <script type="text/javascript" src="../js/materialize.min.js"></script>
        <script type="text/javascript" src="../js/custom.js"></script>
        <link rel="stylesheet" href="../highlight/styles/vs2015.css">
        <script src="../highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
	</body>
</html>
